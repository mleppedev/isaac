{% extends "header.html" %}

{% block extra_css %}
<style>
    .control-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
        margin: 5px;
    }
    
    .control-btn.active {
        background-color: #198754 !important;
        border-color: #198754 !important;
        color: white !important;
    }
    
    .control-btn.shooting.active {
        background-color: #dc3545 !important;
        border-color: #dc3545 !important;
    }
    
    .control-pad {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 20px;
    }
    
    .control-row {
        display: flex;
        justify-content: center;
    }
    
    .control-group {
        display: flex;
        justify-content: space-around;
        flex-wrap: wrap;
    }
    
    .output-console {
        height: 200px;
        overflow-y: auto;
        background-color: #1a1a1a;
        color: #33ff33;
        font-family: monospace;
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
    }
    
    .ai-status {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 5px;
    }
    
    .ai-status.active {
        background-color: #33ff33;
    }
    
    .ai-status.inactive {
        background-color: #ff3333;
    }
    
    .persistent-mode-info {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 15px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <h1 class="mb-4">Control del Personaje</h1>
    
    <!-- Indicador de estado de conexión -->
    <div id="connection-status" class="alert alert-secondary mb-4">
        <h5><i class="bi bi-question-circle me-2"></i>Estado de conexión con el juego</h5>
        <p class="mb-0">Esperando interacción con el juego...</p>
    </div>
    
    <div class="row">
        <div class="col-md-8">
            <!-- Panel de estado -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-info-circle me-2"></i>Estado</h5>
                </div>
                <div class="card-body">
                    <div class="alert alert-info mb-3">
                        <h6><i class="bi bi-lightbulb me-2"></i>Uso del Generador Aleatorio</h6>
                        <p class="mb-0 small">Al activar el generador aleatorio en el panel derecho, comenzará a enviar comandos aleatorios al juego de forma constante. Esto es útil cuando el juego se pausa al perder el foco. 
                        <strong>Instrucciones de uso:</strong></p>
                        <ol class="mb-0 small mt-1">
                            <li>Activa la IA con el botón "Activar IA" (o se activará automáticamente)</li>
                            <li>Activa el modo "Generador Aleatorio" en el panel derecho</li>
                            <li>Regresa al juego y observa cómo el personaje se mueve automáticamente</li>
                            <li>Para detener el comportamiento, vuelve a esta página y desactiva el generador</li>
                        </ol>
                    </div>
                    
                    <div class="alert alert-warning mb-3">
                        <h6><i class="bi bi-exclamation-triangle me-2"></i>¡Importante!</h6>
                        <p class="mb-0 small">Para que el control funcione, es necesario que:</p>
                        <ol class="mb-0 small mt-1">
                            <li>El juego <strong>The Binding of Isaac</strong> esté abierto</li>
                            <li>El mod <strong>Data Event Manager (DEM)</strong> esté activado</li>
                            <li>Si aparecen errores de "No such file or directory", verifica que estés jugando con el mod activo</li>
                        </ol>
                    </div>
                    
                    <div class="persistent-mode-info">
                        <p class="mb-0"><strong>Modo persistente:</strong> 
                            <span class="form-check form-switch d-inline-block ms-2">
                                <input class="form-check-input" type="checkbox" id="persistent-mode-toggle">
                                <label class="form-check-label" for="persistent-mode-toggle">Activar</label>
                            </span>
                        </p>
                        <small class="text-muted">En modo persistente, las teclas mantienen su estado hasta que hagas clic nuevamente o uses "Limpiar entradas"</small>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6">
                            <p>
                                <strong>Modo IA:</strong> 
                                <span id="ai-status">
                                    <span class="ai-status inactive"></span>Desactivado
                                </span>
                            </p>
                            <p><strong>Última acción:</strong> <span id="last-action">Ninguna</span></p>
                            <p><strong>Controles activos:</strong> <span id="active-controls">Ninguno</span></p>
                        </div>
                        <div class="col-md-6 text-end">
                            <button id="toggle-ai-btn" class="btn btn-warning">
                                <i class="bi bi-robot me-1"></i>Activar IA
                            </button>
                            <button id="clear-inputs-btn" class="btn btn-secondary ms-2">
                                <i class="bi bi-x-circle me-1"></i>Limpiar entradas
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Panel de control -->
            <div class="card">
                <div class="card-header">
                    <h5><i class="bi bi-controller me-2"></i>Control Manual</h5>
                </div>
                <div class="card-body">
                    <div class="control-group">
                        <!-- Controles de movimiento WASD -->
                        <div class="control-section">
                            <h5 class="text-center mb-3">Movimiento</h5>
                            <div class="control-pad">
                                <div class="control-row">
                                    <button class="btn btn-primary control-btn" data-action="movement" data-direction="up">
                                        <i class="bi bi-arrow-up"></i>
                                    </button>
                                </div>
                                <div class="control-row">
                                    <button class="btn btn-primary control-btn" data-action="movement" data-direction="left">
                                        <i class="bi bi-arrow-left"></i>
                                    </button>
                                    <button class="btn btn-outline-secondary control-btn invisible">
                                        <i class="bi bi-dot"></i>
                                    </button>
                                    <button class="btn btn-primary control-btn" data-action="movement" data-direction="right">
                                        <i class="bi bi-arrow-right"></i>
                                    </button>
                                </div>
                                <div class="control-row">
                                    <button class="btn btn-primary control-btn" data-action="movement" data-direction="down">
                                        <i class="bi bi-arrow-down"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Controles de disparo -->
                        <div class="control-section">
                            <h5 class="text-center mb-3">Disparo</h5>
                            <div class="control-pad">
                                <div class="control-row">
                                    <button class="btn btn-danger control-btn shooting" data-action="shooting" data-direction="up">
                                        <i class="bi bi-arrow-up"></i>
                                    </button>
                                </div>
                                <div class="control-row">
                                    <button class="btn btn-danger control-btn shooting" data-action="shooting" data-direction="left">
                                        <i class="bi bi-arrow-left"></i>
                                    </button>
                                    <button class="btn btn-outline-secondary control-btn invisible">
                                        <i class="bi bi-dot"></i>
                                    </button>
                                    <button class="btn btn-danger control-btn shooting" data-action="shooting" data-direction="right">
                                        <i class="bi bi-arrow-right"></i>
                                    </button>
                                </div>
                                <div class="control-row">
                                    <button class="btn btn-danger control-btn shooting" data-action="shooting" data-direction="down">
                                        <i class="bi bi-arrow-down"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-4">
            <!-- Consola de salida -->
            <div class="card">
                <div class="card-header">
                    <h5><i class="bi bi-terminal me-2"></i>Consola</h5>
                </div>
                <div class="card-body">
                    <div id="output-console" class="output-console"></div>
                    
                    <div class="mt-3">
                        <button id="clear-console-btn" class="btn btn-sm btn-outline-secondary">
                            <i class="bi bi-trash me-1"></i>Limpiar consola
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Secuencias predefinidas -->
            <div class="card mt-4">
                <div class="card-header">
                    <h5><i class="bi bi-list-check me-2"></i>Secuencias</h5>
                </div>
                <div class="card-body">
                    <p>Secuencias de comandos predefinidas:</p>
                    <button class="btn btn-sm btn-success mb-2" data-sequence="move_right_shoot_up">
                        Mover derecha + Disparar arriba
                    </button>
                    <button class="btn btn-sm btn-success mb-2" data-sequence="circle_pattern">
                        Patrón circular
                    </button>
                    
                    <hr>
                    
                    <div class="form-group">
                        <label for="sequence-file">Cargar secuencia desde archivo:</label>
                        <input type="file" id="sequence-file" class="form-control form-control-sm my-2" accept=".json">
                        <button id="load-sequence-btn" class="btn btn-sm btn-primary">
                            <i class="bi bi-upload me-1"></i>Cargar
                        </button>
                    </div>
                </div>
            </div>

            <!-- Generador de inputs aleatorios -->
            <div class="card mt-4">
                <div class="card-header bg-success text-white">
                    <h5><i class="bi bi-shuffle me-2"></i>Generador Aleatorio</h5>
                </div>
                <div class="card-body">
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="random-input-toggle">
                        <label class="form-check-label" for="random-input-toggle">
                            <strong>Activar Inputs Aleatorios</strong>
                        </label>
                    </div>
                    
                    <div id="random-input-settings">
                        <div class="mb-3">
                            <label for="random-input-interval" class="form-label">Intervalo (ms):</label>
                            <input type="range" class="form-range" id="random-input-interval" 
                                   min="100" max="2000" step="100" value="500">
                            <div class="d-flex justify-content-between">
                                <small>Rápido (100ms)</small>
                                <small id="interval-value">500ms</small>
                                <small>Lento (2000ms)</small>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Tipos de inputs:</label>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="random-movement" checked>
                                <label class="form-check-label" for="random-movement">Movimiento</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="random-shooting" checked>
                                <label class="form-check-label" for="random-shooting">Disparo</label>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Comportamiento:</label>
                            <select class="form-select form-select-sm" id="random-behavior">
                                <option value="completely-random">Completamente aleatorio</option>
                                <option value="smart-random" selected>Semi-inteligente</option>
                                <option value="aggressive">Agresivo</option>
                                <option value="defensive">Defensivo</option>
                            </select>
                            <small class="text-muted d-block mt-1">
                                Semi-inteligente: Dispara en la dirección opuesta al movimiento
                            </small>
                        </div>
                        
                        <div class="mt-3">
                            <span class="badge rounded-pill bg-success" id="random-status">
                                Inactivo
                            </span>
                            <small class="text-muted ms-2" id="random-count">0 comandos enviados</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sección para control del sistema de visión por computadora -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-camera-video me-2"></i>Sistema de Visión por Computadora</h5>
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-8">
                            <p>Este sistema utiliza visión por computadora para detectar elementos del juego y un agente de reinforcement learning para tomar decisiones inteligentes.</p>
                            <div id="vision-status" class="alert alert-secondary">
                                <span id="vision-status-text">El sistema no está inicializado</span>
                            </div>
                        </div>
                        <div class="col-md-4 text-end">
                            <button id="btn-start-vision" class="btn btn-primary mb-2 w-100">
                                <i class="bi bi-play-fill me-1"></i>Iniciar Sistema
                            </button>
                            <button id="btn-stop-vision" class="btn btn-danger mb-2 w-100" disabled>
                                <i class="bi bi-stop-fill me-1"></i>Detener Sistema
                            </button>
                            <button id="btn-check-dependencies" class="btn btn-info mb-2 w-100">
                                <i class="bi bi-check-circle me-1"></i>Verificar Dependencias
                            </button>
                        </div>
                    </div>
                    
                    <!-- Modal para resultados de verificación -->
                    <div class="modal fade" id="dependenciesModal" tabindex="-1" aria-labelledby="dependenciesModalLabel" aria-hidden="true">
                        <div class="modal-dialog modal-lg">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="dependenciesModalLabel">Verificación de Dependencias</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <pre id="dependencies-result" class="p-3 bg-light" style="max-height: 400px; overflow-y: auto;"></pre>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="row" id="vision-controls" style="display: none;">
                        <div class="col-md-6">
                            <div class="card mb-3">
                                <div class="card-header">Configuración</div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <label class="form-label">Tasa de exploración</label>
                                        <input type="range" class="form-range" id="exploration-rate" min="0" max="1" step="0.1" value="0.2">
                                        <div class="d-flex justify-content-between">
                                            <small>0 (Explotación)</small>
                                            <small id="exploration-value">0.2</small>
                                            <small>1 (Exploración)</small>
                                        </div>
                                    </div>
                                    <div class="form-check form-switch mb-3">
                                        <input class="form-check-input" type="checkbox" id="visualization" checked>
                                        <label class="form-check-label" for="visualization">Mostrar visualización</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-3">
                                <div class="card-header">Entrenamiento</div>
                                <div class="card-body">
                                    <p>Captura templates para entrenar el sistema de detección:</p>
                                    <div class="mb-3">
                                        <select class="form-select mb-2" id="template-type">
                                            <option value="player">Jugador</option>
                                            <option value="enemy">Enemigo</option>
                                            <option value="item">Item</option>
                                            <option value="door">Puerta</option>
                                        </select>
                                        <div class="input-group">
                                            <input type="text" class="form-control" id="template-name" placeholder="Nombre">
                                            <button class="btn btn-outline-primary" id="btn-capture-template">
                                                <i class="bi bi-camera me-1"></i>Capturar
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Añadir después del panel de control de visión por computadora -->
            <div class="row mt-3" id="vision-visualization" style="display: none;">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5><i class="bi bi-camera me-2"></i>Visualización en tiempo real</h5>
                            <div>
                                <span class="badge bg-primary" id="detection-fps">0 FPS</span>
                                <button class="btn btn-sm btn-outline-secondary ms-2" id="btn-fullscreen">
                                    <i class="bi bi-fullscreen"></i>
                                </button>
                            </div>
                        </div>
                        <div class="card-body text-center">
                            <div class="vision-container mb-3" style="position: relative;">
                                <img id="vision-feed" src="/static/img/waiting.png" alt="Visualización de IA" class="img-fluid"
                                    style="max-height: 480px; border: 1px solid #ccc; background-color: #f8f9fa;">
                                <div id="vision-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                                    <!-- Las anotaciones se añadirán aquí dinámicamente -->
                                </div>
                            </div>
                            <div class="detection-stats small bg-light p-2 rounded text-start overflow-auto" style="max-height: 120px;">
                                <div id="detection-log">Esperando datos del sistema de visión...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const outputConsole = document.getElementById('output-console');
        const toggleAiBtn = document.getElementById('toggle-ai-btn');
        const clearInputsBtn = document.getElementById('clear-inputs-btn');
        const clearConsoleBtn = document.getElementById('clear-console-btn');
        const aiStatus = document.getElementById('ai-status');
        const lastAction = document.getElementById('last-action');
        const loadSequenceBtn = document.getElementById('load-sequence-btn');
        const sequenceFile = document.getElementById('sequence-file');
        const persistentModeToggle = document.getElementById('persistent-mode-toggle');
        const activeControls = document.getElementById('active-controls');
        
        // Elementos para generación aleatoria
        const randomInputToggle = document.getElementById('random-input-toggle');
        const randomInputInterval = document.getElementById('random-input-interval');
        const intervalValue = document.getElementById('interval-value');
        const randomMovement = document.getElementById('random-movement');
        const randomShooting = document.getElementById('random-shooting');
        const randomBehavior = document.getElementById('random-behavior');
        const randomStatus = document.getElementById('random-status');
        const randomCount = document.getElementById('random-count');
        
        let aiActive = false;
        let persistentMode = false;
        let activeButtons = [];
        
        // Variables para generación aleatoria
        let randomInputActive = false;
        let randomIntervalId = null;
        let commandCount = 0;
        let lastRandomCommand = null;
        let lastMovementDirection = null;
        
        // Actualizar valor del intervalo
        randomInputInterval.addEventListener('input', function() {
            intervalValue.textContent = this.value + 'ms';
            
            // Si estamos generando, reiniciar con el nuevo intervalo
            if (randomInputActive) {
                stopRandomInputs();
                startRandomInputs();
            }
        });
        
        // Alternar generación aleatoria
        randomInputToggle.addEventListener('change', function() {
            randomInputActive = this.checked;
            
            if (randomInputActive) {
                // Asegurarse de que IA está activada
                if (!aiActive) {
                    toggleAiBtn.click();
                }
                
                startRandomInputs();
                randomStatus.textContent = 'Activo';
                randomStatus.classList.remove('bg-success');
                randomStatus.classList.add('bg-danger');
                logToConsole('Generador de inputs aleatorios activado');
            } else {
                stopRandomInputs();
                randomStatus.textContent = 'Inactivo';
                randomStatus.classList.remove('bg-danger');
                randomStatus.classList.add('bg-success');
                logToConsole('Generador de inputs aleatorios desactivado');
                
                // Limpiar entradas
                sendCommand({ type: 'clear' });
            }
        });
        
        // Iniciar generación aleatoria
        function startRandomInputs() {
            if (randomIntervalId) return;
            
            randomIntervalId = setInterval(() => {
                generateRandomInput();
            }, parseInt(randomInputInterval.value));
        }
        
        // Detener generación aleatoria
        function stopRandomInputs() {
            if (randomIntervalId) {
                clearInterval(randomIntervalId);
                randomIntervalId = null;
            }
        }
        
        // Generar un input aleatorio
        function generateRandomInput() {
            const directions = ['up', 'down', 'left', 'right'];
            let command = { type: '', direction: '', value: 1.0 };
            
            // Determinar si generamos movimiento, disparo o ambos
            const generateMovement = randomMovement.checked;
            const generateShooting = randomShooting.checked;
            
            if (!generateMovement && !generateShooting) return;
            
            // Elegir aleatoriamente qué generar si ambos están habilitados
            let inputType = '';
            if (generateMovement && generateShooting) {
                inputType = Math.random() < 0.5 ? 'movement' : 'shooting';
            } else if (generateMovement) {
                inputType = 'movement';
            } else {
                inputType = 'shooting';
            }
            
            command.type = inputType;
            
            // Elegir dirección según comportamiento seleccionado
            const behavior = randomBehavior.value;
            
            if (behavior === 'completely-random') {
                // Dirección completamente aleatoria
                command.direction = directions[Math.floor(Math.random() * directions.length)];
            } 
            else if (behavior === 'smart-random') {
                if (inputType === 'movement') {
                    // Dirección aleatoria para movimiento
                    command.direction = directions[Math.floor(Math.random() * directions.length)];
                    lastMovementDirection = command.direction;
                } else {
                    // Dirección "inteligente" para disparo (opuesta al movimiento)
                    if (lastMovementDirection) {
                        if (lastMovementDirection === 'up') command.direction = 'down';
                        else if (lastMovementDirection === 'down') command.direction = 'up';
                        else if (lastMovementDirection === 'left') command.direction = 'right';
                        else if (lastMovementDirection === 'right') command.direction = 'left';
                    } else {
                        command.direction = directions[Math.floor(Math.random() * directions.length)];
                    }
                }
            }
            else if (behavior === 'aggressive') {
                // Para modo agresivo, disparar más que moverse
                if (inputType === 'movement') {
                    command.direction = directions[Math.floor(Math.random() * directions.length)];
                    lastMovementDirection = command.direction;
                } else {
                    // Más probablemente disparando hacia la derecha e izquierda
                    const shootDirections = ['left', 'right', 'up', 'down', 'left', 'right'];
                    command.direction = shootDirections[Math.floor(Math.random() * shootDirections.length)];
                }
            }
            else if (behavior === 'defensive') {
                // Para modo defensivo, moverse más que disparar
                if (inputType === 'movement') {
                    // Más movimiento vertical
                    const moveDirections = ['up', 'down', 'left', 'right', 'up', 'down'];
                    command.direction = moveDirections[Math.floor(Math.random() * moveDirections.length)];
                    lastMovementDirection = command.direction;
                } else {
                    command.direction = directions[Math.floor(Math.random() * directions.length)];
                }
            }
            
            // Cancelar comando anterior si era del mismo tipo
            if (lastRandomCommand && lastRandomCommand.type === command.type) {
                clearInputsByType(command.type);
            }
            
            // Guardar último comando
            lastRandomCommand = command;
            
            // Enviar comando
            sendCommand(command);
            commandCount++;
            randomCount.textContent = `${commandCount} comandos enviados`;
        }
        
        // Limpiar entradas por tipo
        function clearInputsByType(type) {
            sendCommand({ type: 'clear' });
        }
        
        // Función para actualizar el indicador de controles activos
        function updateActiveControlsText() {
            if (activeButtons.length === 0) {
                activeControls.textContent = "Ninguno";
            } else {
                activeControls.textContent = activeButtons.map(btn => {
                    const action = btn.getAttribute('data-action');
                    const direction = btn.getAttribute('data-direction');
                    return `${action} ${direction}`;
                }).join(', ');
            }
        }
        
        // Función para añadir mensaje a la consola
        function logToConsole(message, isError = false) {
            const entry = document.createElement('div');
            entry.className = isError ? 'text-danger' : '';
            entry.innerHTML = `<span class="text-secondary">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            outputConsole.appendChild(entry);
            outputConsole.scrollTop = outputConsole.scrollHeight;
        }
        
        // Función para enviar un comando al servidor
        async function sendCommand(command) {
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(command),
                });
                
                const data = await response.json();
                logToConsole(JSON.stringify(data));
                lastAction.textContent = `${command.type} - ${command.direction || ''}`;
                return data;
            } catch (error) {
                logToConsole(`Error: ${error.message}`, true);
                return null;
            }
        }
        
        // Toggle para modo persistente
        persistentModeToggle.addEventListener('change', function() {
            persistentMode = this.checked;
            logToConsole(`Modo persistente: ${persistentMode ? 'Activado' : 'Desactivado'}`);
            
            // Si se desactiva el modo persistente, limpiar todos los botones activos
            if (!persistentMode) {
                activeButtons.forEach(btn => {
                    btn.classList.remove('active');
                });
                activeButtons = [];
                updateActiveControlsText();
                sendCommand({ type: 'clear' });
            }
        });
        
        // Configurar botones de control
        document.querySelectorAll('[data-action]').forEach(button => {
            button.addEventListener('click', function() {
                const action = this.getAttribute('data-action');
                const direction = this.getAttribute('data-direction');
                
                if (persistentMode) {
                    // En modo persistente, alternar estado del botón
                    if (this.classList.contains('active')) {
                        // Desactivar - quitar de activos y enviar comando de limpieza
                        this.classList.remove('active');
                        activeButtons = activeButtons.filter(btn => btn !== this);
                        updateActiveControlsText();
                        
                        // Solo enviar clear si no quedan botones activos
                        if (activeButtons.length === 0) {
                            sendCommand({ type: 'clear' });
                            logToConsole('Deteniendo todas las acciones');
                        } else {
                            // Reenviar comandos para los botones que aún están activos
                            activeButtons.forEach(btn => {
                                const btnAction = btn.getAttribute('data-action');
                                const btnDirection = btn.getAttribute('data-direction');
                                sendCommand({
                                    type: btnAction,
                                    direction: btnDirection,
                                    value: 1.0
                                });
                            });
                        }
                    } else {
                        // Activar - añadir a activos y enviar comando
                        this.classList.add('active');
                        activeButtons.push(this);
                        updateActiveControlsText();
                        
                        logToConsole(`Modo persistente: ${action} ${direction}`);
                        sendCommand({
                            type: action,
                            direction: direction,
                            value: 1.0
                        });
                    }
                } else {
                    // Modo normal - enviar comando una vez
                    logToConsole(`Enviando comando: ${action} ${direction}`);
                    sendCommand({
                        type: action,
                        direction: direction,
                        value: 1.0
                    });
                }
            });
        });
        
        // Botón para alternar IA
        toggleAiBtn.addEventListener('click', function() {
            aiActive = !aiActive;
            sendCommand({ type: 'toggle_ai' });
            
            if (aiActive) {
                aiStatus.innerHTML = '<span class="ai-status active"></span>Activado';
                toggleAiBtn.innerHTML = '<i class="bi bi-robot me-1"></i>Desactivar IA';
                toggleAiBtn.classList.replace('btn-warning', 'btn-success');
            } else {
                aiStatus.innerHTML = '<span class="ai-status inactive"></span>Desactivado';
                toggleAiBtn.innerHTML = '<i class="bi bi-robot me-1"></i>Activar IA';
                toggleAiBtn.classList.replace('btn-success', 'btn-warning');
            }
            
            logToConsole(`Modo IA: ${aiActive ? 'Activado' : 'Desactivado'}`);
        });
        
        // Botón para limpiar entradas
        clearInputsBtn.addEventListener('click', function() {
            sendCommand({ type: 'clear' });
            logToConsole('Limpiando todas las entradas');
            
            // Limpiar botones activos en modo persistente
            activeButtons.forEach(btn => {
                btn.classList.remove('active');
            });
            activeButtons = [];
            updateActiveControlsText();
        });
        
        // Botón para limpiar consola
        clearConsoleBtn.addEventListener('click', function() {
            outputConsole.innerHTML = '';
        });
        
        // Secuencias predefinidas
        document.querySelectorAll('[data-sequence]').forEach(button => {
            button.addEventListener('click', async function() {
                const sequenceName = this.getAttribute('data-sequence');
                logToConsole(`Ejecutando secuencia: ${sequenceName}`);
                
                let commands = [];
                
                if (sequenceName === 'move_right_shoot_up') {
                    commands = [
                        { type: 'movement', direction: 'right', value: 1.0 },
                        { type: 'shooting', direction: 'up', value: 1.0 },
                        { type: 'clear' }
                    ];
                } else if (sequenceName === 'circle_pattern') {
                    commands = [
                        { type: 'movement', direction: 'right', value: 1.0 },
                        { type: 'movement', direction: 'up', value: 1.0 },
                        { type: 'movement', direction: 'left', value: 1.0 },
                        { type: 'movement', direction: 'down', value: 1.0 },
                        { type: 'clear' }
                    ];
                }
                
                if (commands.length > 0) {
                    const response = await fetch('/api/control/sequence', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(commands),
                    });
                    
                    const data = await response.json();
                    logToConsole(`Secuencia completada: ${JSON.stringify(data)}`);
                }
            });
        });
        
        // Cargar secuencia desde archivo
        loadSequenceBtn.addEventListener('click', function() {
            if (!sequenceFile.files || !sequenceFile.files[0]) {
                logToConsole('Error: No se ha seleccionado ningún archivo', true);
                return;
            }
            
            const file = sequenceFile.files[0];
            if (!file.name.endsWith('.json')) {
                logToConsole('Error: El archivo debe ser JSON', true);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const commands = JSON.parse(e.target.result);
                    logToConsole(`Cargada secuencia desde ${file.name}: ${commands.length} comandos`);
                    
                    const response = await fetch('/api/control/sequence', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(commands),
                    });
                    
                    const data = await response.json();
                    logToConsole(`Secuencia completada: ${JSON.stringify(data)}`);
                } catch (error) {
                    logToConsole(`Error al cargar secuencia: ${error.message}`, true);
                }
            };
            reader.readAsText(file);
        });
        
        // Mensaje inicial
        logToConsole('Panel de control inicializado');
        
        // Función para actualizar el estado de conexión con el juego
        function updateConnectionStatus(status, message, isError = false) {
            const connectionStatus = document.getElementById('connection-status');
            
            // Limpiar clases previas
            connectionStatus.classList.remove('alert-success', 'alert-danger', 'alert-secondary', 'alert-warning');
            
            let icon = '';
            if (status === 'connected') {
                connectionStatus.classList.add('alert-success');
                icon = '<i class="bi bi-check-circle-fill me-2"></i>';
            } else if (status === 'disconnected') {
                connectionStatus.classList.add('alert-danger');
                icon = '<i class="bi bi-x-circle-fill me-2"></i>';
            } else if (status === 'waiting') {
                connectionStatus.classList.add('alert-secondary');
                icon = '<i class="bi bi-question-circle me-2"></i>';
            } else if (status === 'warning') {
                connectionStatus.classList.add('alert-warning');
                icon = '<i class="bi bi-exclamation-triangle-fill me-2"></i>';
            }
            
            connectionStatus.innerHTML = `
                <h5>${icon}Estado de conexión con el juego</h5>
                <p class="mb-0">${message}</p>
            `;
            
            if (isError) {
                logToConsole(`Error de conexión: ${message}`, true);
            }
        }
        
        // Interceptar respuestas de la API para actualizar el estado de conexión
        const originalFetch = window.fetch;
        window.fetch = function(input, init) {
            const promise = originalFetch.apply(this, arguments);
            
            // Solo interceptar llamadas a la API de control
            if (input.toString().includes('/api/control')) {
                promise.then(response => {
                    response.clone().json().then(data => {
                        if (data.success) {
                            updateConnectionStatus('connected', 'Conectado correctamente al juego');
                        } else {
                            if (data.description) {
                                updateConnectionStatus('disconnected', data.description, true);
                            } else {
                                updateConnectionStatus('disconnected', 'Error en la comunicación con el juego', true);
                            }
                        }
                    }).catch(err => {
                        updateConnectionStatus('warning', 'Respuesta inválida del servidor', true);
                    });
                }).catch(err => {
                    updateConnectionStatus('disconnected', 'No se pudo conectar con el servidor', true);
                });
            }
            
            return promise;
        };
        
        // Estado inicial
        updateConnectionStatus('waiting', 'Esperando interacción con el juego...');
    });
    
    // Variables globales para el estado de los controles
    var controlData = {
        movement: {
            up: false,
            down: false,
            left: false,
            right: false
        },
        shooting: {
            up: false,
            down: false,
            left: false,
            right: false
        },
        actions: {
            bomb: false,
            item: false
        },
        persistent: false,
        aiControl: false,
        lastCommand: null
    };
    
    // JavaScript para la sección de visión por computadora
    // Estado del sistema de visión
    let visionSystemRunning = false;
    
    // Actualizar interfaz según el estado del sistema
    function updateVisionUI(status) {
        visionSystemRunning = status === 'running';
        
        $('#btn-start-vision').prop('disabled', visionSystemRunning);
        $('#btn-stop-vision').prop('disabled', !visionSystemRunning);
        
        if (visionSystemRunning) {
            $('#vision-status').removeClass('alert-secondary alert-danger').addClass('alert-success');
            $('#vision-status-text').text('Sistema de visión en ejecución');
            $('#vision-controls').show();
            startVisionVisualization();
        } else if (status === 'error') {
            $('#vision-status').removeClass('alert-secondary alert-success').addClass('alert-danger');
            $('#vision-status-text').text('Error en el sistema de visión');
            $('#vision-controls').hide();
            stopVisionVisualization();
        } else {
            $('#vision-status').removeClass('alert-success alert-danger').addClass('alert-secondary');
            $('#vision-status-text').text('Sistema de visión detenido');
            $('#vision-controls').hide();
            stopVisionVisualization();
        }
    }
    
    // Verificar el estado inicial del sistema
    function checkVisionStatus() {
        fetch('/api/vision')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                updateVisionUI(data.status || 'stopped');
            })
            .catch(error => {
                console.error('Error al verificar estado del sistema de visión:', error);
                // No mostrar error en la interfaz, simplemente inicializar como detenido
                updateVisionUI('stopped');
            });
    }
    
    // Iniciar el sistema de visión
    $('#btn-start-vision').click(function() {
        // Configuración del sistema
        const config = {
            'visualize': $('#visualization').is(':checked'),
            'agent': {
                'exploration_rate': parseFloat($('#exploration-rate').val())
            }
        };
        
        // Enviar solicitud para iniciar
        fetch('/api/vision', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                action: 'start',
                config: config
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                updateVisionUI('running');
                showNotification('success', 'Sistema de visión iniciado');
            } else {
                updateVisionUI('error');
                showNotification('error', data.message || 'Error al iniciar el sistema');
            }
        })
        .catch(error => {
            console.error('Error al iniciar sistema de visión:', error);
            updateVisionUI('error');
            showNotification('error', 'Error de conexión');
        });
    });
    
    // Detener el sistema de visión
    $('#btn-stop-vision').click(function() {
        fetch('/api/vision', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                action: 'stop'
            })
        })
        .then(response => response.json())
        .then(data => {
            updateVisionUI('stopped');
            showNotification('info', 'Sistema de visión detenido');
        })
        .catch(error => {
            console.error('Error al detener sistema de visión:', error);
            showNotification('error', 'Error de conexión');
        });
    });
    
    // Capturar template para entrenamiento
    $('#btn-capture-template').click(function() {
        const templateType = $('#template-type').val();
        const templateName = $('#template-name').val();
        
        if (!templateName) {
            showNotification('warning', 'Ingrese un nombre para el template');
            return;
        }
        
        fetch('/api/vision', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                action: 'save_template',
                template_type: templateType,
                name: templateName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                showNotification('success', 'Template guardado correctamente');
                $('#template-name').val('');  // Limpiar el campo
            } else {
                showNotification('error', data.message || 'Error al guardar template');
            }
        })
        .catch(error => {
            console.error('Error al guardar template:', error);
            showNotification('error', 'Error de conexión');
        });
    });
    
    // Actualizar valor del slider de exploración
    $('#exploration-rate').on('input', function() {
        $('#exploration-value').text($(this).val());
    });
    
    // Cuando el documento esté listo
    $(document).ready(function() {
        // Verificar estado del sistema de visión
        checkVisionStatus();
    });

    // Funciones auxiliares que faltaban
    function updateButtonStates() {
        // Esta función se encargaría de actualizar estados de botones
        // Implementación vacía para evitar errores
        console.log("updateButtonStates: Función implementada como no-op");
    }
    
    function getPersistentModeState() {
        // Esta función se encargaría de obtener el estado del modo persistente
        // Implementación vacía para evitar errores
        console.log("getPersistentModeState: Función implementada como no-op");
    }
    
    function getAIControlState() {
        // Esta función se encargaría de obtener el estado del control de IA
        // Implementación vacía para evitar errores
        console.log("getAIControlState: Función implementada como no-op");
    }
    
    function showNotification(type, message) {
        // Sistema simple de notificaciones
        const alertClass = type === 'success' ? 'alert-success' : 
                          type === 'error' ? 'alert-danger' : 
                          type === 'warning' ? 'alert-warning' : 'alert-info';
        
        // Crear elemento de notificación
        const notification = $(`<div class="alert ${alertClass} alert-dismissible fade show" role="alert">
            <strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong> ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>`);
        
        // Añadir al DOM
        $('body').append(notification);
        
        // Ubicar en la esquina superior derecha
        notification.css({
            'position': 'fixed',
            'top': '20px',
            'right': '20px',
            'z-index': '9999',
            'min-width': '300px'
        });
        
        // Eliminar después de 5 segundos
        setTimeout(() => {
            notification.alert('close');
        }, 5000);
        
        // También mostrar en consola
        console.log(`${type}: ${message}`);
    }
    
    // Variables para la visualización
    let visionInterval = null;
    let lastProcessedFrame = null;
    let frameCount = 0;
    let lastFpsUpdate = Date.now();
    
    // Función para iniciar la visualización
    function startVisionVisualization() {
        // Mostrar el panel de visualización
        $('#vision-visualization').show();
        
        // Actualizar la imagen cada 100ms (10 FPS máximo para no sobrecargar)
        visionInterval = setInterval(function() {
            // Añadir timestamp para evitar caché
            const timestamp = new Date().getTime();
            $('#vision-feed').attr('src', `/api/vision/frame?t=${timestamp}`);
            
            // Actualizar contador de FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate > 1000) {  // Actualizar cada segundo
                const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                $('#detection-fps').text(`${fps} FPS`);
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            // Obtener información de detección
            fetch('/api/vision/detection')
                .then(response => response.json())
                .then(data => {
                    if (data && data.frame_id !== lastProcessedFrame) {
                        lastProcessedFrame = data.frame_id;
                        updateDetectionLog(data);
                    }
                })
                .catch(error => {
                    console.error('Error al obtener datos de detección:', error);
                });
        }, 100);
    }
    
    // Función para detener la visualización
    function stopVisionVisualization() {
        if (visionInterval) {
            clearInterval(visionInterval);
            visionInterval = null;
        }
        $('#vision-visualization').hide();
    }
    
    // Actualizar el log de detección
    function updateDetectionLog(data) {
        const log = $('#detection-log');
        
        // Crear mensaje HTML
        let html = `<strong>Frame ${data.frame_id}</strong> - ${data.timestamp}<br>`;
        
        // Añadir información del jugador
        if (data.player) {
            html += `<span class="text-success">Jugador: (${Math.round(data.player.x)}, ${Math.round(data.player.y)}) - Conf: ${data.player.confidence.toFixed(2)}</span><br>`;
        } else {
            html += `<span class="text-muted">Jugador: No detectado</span><br>`;
        }
        
        // Añadir información de enemigos
        const enemyCount = data.enemies ? data.enemies.length : 0;
        html += `<span class="text-danger">Enemigos: ${enemyCount}</span>`;
        
        // Añadir información de ítems
        const itemCount = data.items ? data.items.length : 0;
        if (itemCount > 0) {
            html += ` | <span class="text-primary">Items: ${itemCount}</span>`;
        }
        
        // Añadir información de puertas
        const doorCount = data.doors ? data.doors.length : 0;
        if (doorCount > 0) {
            html += ` | <span class="text-warning">Puertas: ${doorCount}</span>`;
        }
        
        // Añadir tiempo de procesamiento
        if (data.processing_time) {
            html += ` | <span class="text-muted">Tiempo: ${(data.processing_time * 1000).toFixed(1)}ms</span>`;
        }
        
        log.html(html);
    }
    
    // Botón para verificar dependencias
    $('#btn-check-dependencies').click(function() {
        $(this).prop('disabled', true);
        $(this).html('<i class="bi bi-hourglass-split me-1"></i>Verificando...');
        
        // Mostrar modal con mensaje de espera
        $('#dependencies-result').html('Verificando dependencias, por favor espere...');
        $('#dependenciesModal').modal('show');
        
        // Enviar solicitud para verificar dependencias
        fetch('/api/vision', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                action: 'check_dependencies'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Mostrar resultado en el modal
                $('#dependencies-result').html(data.output);
            } else {
                // Mostrar error
                $('#dependencies-result').html(`Error: ${data.message || 'Error desconocido'}`);
            }
        })
        .catch(error => {
            console.error('Error al verificar dependencias:', error);
            $('#dependencies-result').html(`Error de conexión: ${error.message || 'Error desconocido'}`);
        })
        .finally(() => {
            // Restaurar botón
            $('#btn-check-dependencies').prop('disabled', false);
            $('#btn-check-dependencies').html('<i class="bi bi-check-circle me-1"></i>Verificar Dependencias');
        });
    });
</script>
{% endblock %} 